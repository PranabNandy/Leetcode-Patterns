## Thumb Rule:
1. **Recursion :** n --> 1   ðŸ’ŠðŸ’Š    => **Tabulation** : 1 --> n

2. ðŸ› 
- `3D array` --> **2D array**  
-  `2D array` --> **2 x  1D array**   --> **`Single 1D array`** { prev, curr }
-  `1D array` --> **2 variable ( one exception case)**  

3. ðŸ’» Infinite supply / multiple uses ---> stay in the same index

4. ðŸ”‘ if base condition is 
```c++
 if(j<0) return i ;
// Then make it to
if(j==0) return i+1;
```



5. ðŸ’¡ During shifting from prev, curr ----> curr 
take care of this condition like
```c++
for(int i=0;i<=n;i++) prev[i]=i+1;
// From that to this
curr[0]= i+1;
```
![Image](https://github.com/user-attachments/assets/31b8307b-77f0-4057-b218-c9a2c925dd72)

### distinct-subsequences
From **2* 1D array to 1* 1D array** ----> j=m;j>=1; j--  ---> It is reverse in this case
https://leetcode.com/problems/distinct-subsequences/submissions/1557202118/

6. gcd(a,b):
```c++
 gcd(a,b)
{     
    if(a>b)  a=a%b;  gcd(b,a%b);
}
```
7.  Don't use **sqrt()** functions
```c++
for(int i=1;i<sqrt(n);i++)   ===> Use this one ==>  for (int i=1; i*i <n ;i++) 
```
8. Prime Factor : O(sqrt(n))
```c++
for(i:2 -> sqrt(n))
{ 
    if(n%i==0){
           list.add (i)
           if(n%i==0)  n=n/i;
}
if(n!=1) list.add(n);
```

9. pow() function in O(logn) time

```c++
int power(int x, int y) {
int ans=1;
while(y>0){
       if(y%2){
           ans=ans*x;    // y==1
           y=y-1;
      }
      else{
        x=x*x;
        y=y/2;
      }
}
return ans;
```

10. Print all prime number from 2 to N 

![Image](https://github.com/user-attachments/assets/d4c5ccec-2592-4b23-83ff-1405ee79d29e)
